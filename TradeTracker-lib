//@version=5

// @description Simple Library for tracking trades
library("TradeTracker", overlay = true)

// @type Has the constituents to track trades generated by any method.
// @field direction Trade direction. Positive values for long and negative values for short trades
// @field initialEntry Initial entry price. This value will not change even if the entry is changed in the lifecycle of the trade
// @field entry Updated entry price. Allows variations to initial calculated entry. Useful in cases of trailing entry.
// @field initialStop Initial stop. Similar to initial entry, this is the first calculated stop for the lifecycle of trade. 
// @field stop Trailing Stop. If there is no trailing, the value will be same as that of initial trade
// @field targets array of target values.
// @field startBar bar index of starting bar. Set by default when object is created. No need to alter this after that.
// @field endBar bar index of last bar in trade. Set by tracker on each execution
// @field startTime time of the start bar. Set by default when object is created. No need to alter this after that.
// @field endTime time of the ending bar. Updated by tracking method.
// @field status Integer parameter to track the status of the trade
// @field retest Boolean parameter to notify if there was retest of the entry price
export type Trade
	int id
	int direction
	float initialEntry
	float entry
	float initialStop
	float stop
	array<float> targets
	int startBar = bar_index
	int endBar = bar_index
	int startTime = time
	int endTime = time
	int status = 0
	bool retest = false

// @function tracks trade when called on every bar
// @param this Trade object
// @returns current Trade object
export method track(Trade this)=>
	if(this.status != -1 and this.status != this.targets.size()+1)
		stopValue = this.direction > 0? low : high
		targetValue = this.direction > 0? high : low
		stopped = stopValue * this.direction <= this.stop * this.direction
		newStatus = this.status
		if (targetValue >= this.entry)
			newStatus +=1
			for target in this.targets
				if(targetValue*this.direction >= target * this.direction)
					newStatus+=1
		this.retest := this.status >= 1 and (stopValue * this.direction <= this.entry * this.direction) ? true : this.retest
		this.status := stopped? -1 : math.max(this.status, newStatus)
		this.endBar := bar_index
		this.endTime := time
	this
